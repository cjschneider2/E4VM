module 'gb_trees'
export ['balance'/1,
	'delete'/2,
	'delete_any'/2,
	'empty'/0,
	'enter'/3,
	'from_orddict'/1,
	'get'/2,
	'insert'/3,
	'is_defined'/2,
	'is_empty'/1,
	'iterator'/1,
	'iterator_from'/2,
	'keys'/1,
	'largest'/1,
	'lookup'/2,
	'map'/2,
	'module_info'/0,
	'module_info'/1,
	'next'/1,
	'size'/1,
	'smallest'/1,
	'take_largest'/1,
	'take_smallest'/1,
	'to_list'/1,
	'update'/3,
	'values'/1]
attributes []
fdef 'empty'/0() =
  <<{0,nil}>>
fdef 'is_empty'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_literal
	  {0,nil} ->
	    <<'true'>>
      <<'false'>>
  end >> <>
fdef 'size'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    when 
		 try
		   do
		     bif (remote 'erlang':'is_integer'/1)(_ker2) >> <_cor1>
		   then
		   do
		     bif (remote 'erlang':'>='/2)(_ker2, 0) >> <_cor2>
		   then
		   do
		     bif (remote 'erlang':'and'/2)(_cor1, _cor2) >> <_ker4>
		   then
		   test (remote 'erlang':'=:='/2)(_ker4, 'true')
		 of _ker3
		   _ker3
		 catch 
		   'false'
		 end
		 ->
		   <<_ker2>>
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'lookup'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker3,_ker2} ->
	    enter (local 'lookup_1'/2)(_cor1, _ker2)
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'lookup_1'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker7,_ker6,_ker5,_ker4} ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'<'/2)(_cor1, _ker7)
		   of _ker8
		     _ker8
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'lookup_1'/2)(_cor1, _ker5)
		   try
		     test (remote 'erlang':'>'/2)(_cor1, _ker7)
		   of _ker9
		     _ker9
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'lookup_1'/2)(_cor1, _ker4)
	      do
		{'value',_ker6} >> <_ker10>
	      then
	      <<_ker10>>
	type k_atom
	  'nil' ->
	    <<'none'>>
      do
	[_cor0] >> <_ker2>
      then
      do
	[_cor1|_ker2] >> <_ker3>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker3)
  end >> <>
fdef 'is_defined'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker3,_ker2} ->
	    enter (local 'is_defined_1'/2)(_cor1, _ker2)
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'is_defined_1'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker7,_ker6,_ker5,_ker4} ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'<'/2)(_cor1, _ker7)
		   of _ker8
		     _ker8
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'is_defined_1'/2)(_cor1, _ker5)
		   try
		     test (remote 'erlang':'>'/2)(_cor1, _ker7)
		   of _ker9
		     _ker9
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'is_defined_1'/2)(_cor1, _ker4)
	      <<'true'>>
	type k_atom
	  'nil' ->
	    <<'false'>>
      do
	[_cor0] >> <_ker2>
      then
      do
	[_cor1|_ker2] >> <_ker3>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker3)
  end >> <>
fdef 'get'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker3,_ker2} ->
	    enter (local 'get_1'/2)(_cor1, _ker2)
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'get_1'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker7,_ker6,_ker5,_ker4} ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'<'/2)(_cor1, _ker7)
		   of _ker8
		     _ker8
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'get_1'/2)(_cor1, _ker5)
		   try
		     test (remote 'erlang':'>'/2)(_cor1, _ker7)
		   of _ker9
		     _ker9
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'get_1'/2)(_cor1, _ker4)
	      <<_ker6>>
      do
	[_cor0] >> <_ker2>
      then
      do
	[_cor1|_ker2] >> <_ker3>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker3)
  end >> <>
fdef 'update'/3(_cor2, _cor1, _cor0) =
  match _cor2,_cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker4,_ker3} ->
	    do
	      call (local 'update_1'/3)(_cor2, _cor1, _ker3) >> <T1>
	    then
	    do
	      {_ker4,T1} >> <_ker5>
	    then
	    <<_ker5>>
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      do
	[_cor2|_ker1] >> <_ker2>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker2)
  end >> <>
fdef 'update_1'/3(_cor2, _cor1, _cor0) =
  match _cor2,_cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker16,_ker15,_ker14,_ker13} ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'<'/2)(_cor2, _ker16)
		   of _ker17
		     _ker17
		   catch 
		     'false'
		   end
		   ->
		     do
		       call (local 'update_1'/3)(_cor2, _cor1, _ker14) >> <_cor3>
		     then
		     do
		       {_ker16,_ker15,_cor3,_ker13} >> <_ker20>
		     then
		     <<_ker20>>
		   try
		     test (remote 'erlang':'>'/2)(_cor2, _ker16)
		   of _ker18
		     _ker18
		   catch 
		     'false'
		   end
		   ->
		     do
		       call (local 'update_1'/3)(_cor2, _cor1, _ker13) >> <_cor4>
		     then
		     do
		       {_ker16,_ker15,_ker14,_cor4} >> <_ker19>
		     then
		     <<_ker19>>
	      do
		{_cor2,_cor1,_ker14,_ker13} >> <_ker21>
	      then
	      <<_ker21>>
      do
	[_cor0] >> <_ker10>
      then
      do
	[_cor1|_ker10] >> <_ker11>
      then
      do
	[_cor2|_ker11] >> <_ker12>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker12)
  end >> <>
fdef 'insert'/3(_cor2, _cor1, _cor0) =
  match _cor2,_cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker4,_ker3} ->
	    when 
		 try
		   test (remote 'erlang':'is_integer'/1)(_ker4)
		 of _ker5
		   _ker5
		 catch 
		   'false'
		 end
		 ->
		   do
		     bif (remote 'erlang':'+'/2)(_ker4, 1) >> <S1>
		   then
		   do
		     bif (remote 'erlang':'*'/2)(S1, S1) >> <_cor4>
		   then
		   do
		     call (local 'insert_1'/4)(_cor2, _cor1, _ker3, _cor4) >> <_cor5>
		   then
		   do
		     {S1,_cor5} >> <_ker6>
		   then
		   <<_ker6>>
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      do
	[_cor2|_ker1] >> <_ker2>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker2)
  end >> <>
fdef 'insert_1'/4(_cor3, _cor2, _cor1, _cor0) =
  match _cor3,_cor2,_cor1,_cor0
    alt
      select _cor1
	type k_tuple
	  {_ker17,_ker16,_ker15,_ker14} ->
	    when 
		 try
		   test (remote 'erlang':'<'/2)(_cor3, _ker17)
		 of _ker18
		   _ker18
		 catch 
		   'false'
		 end
		 ->
		   do
		     bif (remote 'erlang':'bsr'/2)(_cor0, 1) >> <_cor4>
		   then
		   do
		     call (local 'insert_1'/4)(_cor3, _cor2, _ker15, _cor4) >> <_ker19>
		   then
		   match _ker19
		     alt
		       select _ker19
			 type k_tuple
			   {_ker23,_ker22,_ker21} ->
			     do
			       {_ker17,_ker16,_ker23,_ker14} >> <T>
			     then
			     do
			       call (local 'count'/1)(_ker14) >> <_ker24>
			     then
			     match _ker24
			       alt
				 select _ker24
				   type k_tuple
				     {_ker27,_ker26} ->
				       do
					 call (remote 'erlang':'max'/2)(_ker22, _ker27) >> <_cor7>
				       then
				       do
					 bif (remote 'erlang':'bsl'/2)(_cor7, 1) >> <H>
				       then
				       do
					 bif (remote 'erlang':'+'/2)(_ker21, _ker26) >> <_cor9>
				       then
				       do
					 bif (remote 'erlang':'+'/2)(_cor9, 1) >> <SS>
				       then
				       do
					 bif (remote 'erlang':'*'/2)(SS, SS) >> <P>
				       then
				       match 
					 alt
					   when 
						try
						  test (remote 'erlang':'>'/2)(H, P)
						of _ker28
						  _ker28
						catch 
						  'false'
						end
						->
						  enter (local 'balance'/2)(T, SS)
					   do
					     {T,H,SS} >> <_ker55>
					   then
					   <<_ker55>>
				       end >> <>
				 do
				   {'badmatch',_ker24} >> <_ker25>
				 then
				 enter (remote 'erlang':'error'/1)(_ker25)
			     end >> <>
		       do
			 {_ker17,_ker16,_ker19,_ker14} >> <_ker56>
		       then
		       <<_ker56>>
		   end >> <>
		 try
		   test (remote 'erlang':'>'/2)(_cor3, _ker17)
		 of _ker29
		   _ker29
		 catch 
		   'false'
		 end
		 ->
		   do
		     bif (remote 'erlang':'bsr'/2)(_cor0, 1) >> <_cor13>
		   then
		   do
		     call (local 'insert_1'/4)(_cor3, _cor2, _ker14, _cor13) >> <_ker30>
		   then
		   match _ker30
		     alt
		       select _ker30
			 type k_tuple
			   {_ker37,_ker36,_ker35} ->
			     do
			       {_ker17,_ker16,_ker15,_ker37} >> <_ker38>
			     then
			     do
			       call (local 'count'/1)(_ker15) >> <_ker39>
			     then
			     match _ker39
			       alt
				 select _ker39
				   type k_tuple
				     {_ker44,_ker43} ->
				       do
					 call (remote 'erlang':'max'/2)(_ker36, _ker44) >> <_cor16>
				       then
				       do
					 bif (remote 'erlang':'bsl'/2)(_cor16, 1) >> <_ker45>
				       then
				       do
					 bif (remote 'erlang':'+'/2)(_ker35, _ker43) >> <_cor18>
				       then
				       do
					 bif (remote 'erlang':'+'/2)(_cor18, 1) >> <_ker46>
				       then
				       do
					 bif (remote 'erlang':'*'/2)(_ker46, _ker46) >> <_ker47>
				       then
				       match 
					 alt
					   when 
						try
						  test (remote 'erlang':'>'/2)(_ker45, _ker47)
						of _ker48
						  _ker48
						catch 
						  'false'
						end
						->
						  enter (local 'balance'/2)(_ker38, _ker46)
					   do
					     {_ker38,_ker45,_ker46} >> <_ker53>
					   then
					   <<_ker53>>
				       end >> <>
				 do
				   {'badmatch',_ker39} >> <_ker42>
				 then
				 enter (remote 'erlang':'error'/1)(_ker42)
			     end >> <>
		       do
			 {_ker17,_ker16,_ker15,_ker30} >> <_ker54>
		       then
		       <<_ker54>>
		   end >> <>
	type k_atom
	  'nil' ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'=:='/2)(_cor0, 0)
		   of _ker49
		     _ker49
		   catch 
		     'false'
		   end
		   ->
		     do
		       {_cor3,_cor2,'nil','nil'} >> <_ker50>
		     then
		     do
		       {_ker50,1,1} >> <_ker51>
		     then
		     <<_ker51>>
	      do
		{_cor3,_cor2,'nil','nil'} >> <_ker52>
	      then
	      <<_ker52>>
      do
	{'key_exists',_cor3} >> <_ker13>
      then
      enter (remote 'erlang':'error'/1)(_ker13)
  end >> <>
fdef 'enter'/3(_cor2, _cor1, _cor0) =
  do
    call (local 'is_defined'/2)(_cor2, _cor0) >> <_ker0>
  then
  match _ker0
    alt
      select _ker0
	type k_atom
	  'false' ->
	    enter (local 'insert'/3)(_cor2, _cor1, _cor0)
	  'true' ->
	    enter (local 'update'/3)(_cor2, _cor1, _cor0)
      do
	{'case_clause',_ker0} >> <_ker1>
      then
      enter (remote 'erlang':'error'/1)(_ker1)
  end >> <>
fdef 'count'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker4,_ker3,_ker2,_ker1} ->
	    alt
	      select _ker2
		type k_atom
		  'nil' ->
		    select _ker1
		      type k_atom
			'nil' ->
			  <<{1,1}>>
	      do
		call (local 'count'/1)(_ker2) >> <_ker5>
	      then
	      match _ker5
		alt
		  select _ker5
		    type k_tuple
		      {_ker8,_ker7} ->
			do
			  call (local 'count'/1)(_ker1) >> <_ker9>
			then
			match _ker9
			  alt
			    select _ker9
			      type k_tuple
				{_ker12,_ker11} ->
				  do
				    call (remote 'erlang':'max'/2)(_ker8, _ker12) >> <_cor5>
				  then
				  do
				    bif (remote 'erlang':'bsl'/2)(_cor5, 1) >> <_cor6>
				  then
				  do
				    bif (remote 'erlang':'+'/2)(_ker7, _ker11) >> <_cor3>
				  then
				  do
				    bif (remote 'erlang':'+'/2)(_cor3, 1) >> <_cor4>
				  then
				  do
				    {_cor6,_cor4} >> <_ker13>
				  then
				  <<_ker13>>
			    do
			      {'badmatch',_ker9} >> <_ker10>
			    then
			    enter (remote 'erlang':'error'/1)(_ker10)
			end >> <>
		  do
		    {'badmatch',_ker5} >> <_ker6>
		  then
		  enter (remote 'erlang':'error'/1)(_ker6)
	      end >> <>
	type k_atom
	  'nil' ->
	    <<{1,0}>>
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'balance'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    do
	      call (local 'balance'/2)(_ker1, _ker2) >> <_cor1>
	    then
	    do
	      {_ker2,_cor1} >> <_ker3>
	    then
	    <<_ker3>>
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'balance'/2(_cor1, _cor0) =
  do
    call (local 'to_list_1'/1)(_cor1) >> <_cor2>
  then
  enter (local 'balance_list'/2)(_cor2, _cor0)
fdef 'balance_list'/2(_cor1, _cor0) =
  do
    call (local 'balance_list_1'/2)(_cor1, _cor0) >> <_ker0>
  then
  match _ker0
    alt
      select _ker0
	type k_tuple
	  {_ker3,_ker2} ->
	    select _ker2
	      type k_nil
		[] ->
		  <<_ker3>>
      do
	{'badmatch',_ker0} >> <_ker1>
      then
      enter (remote 'erlang':'error'/1)(_ker1)
  end >> <>
fdef 'balance_list_1'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      when 
	   try
	     test (remote 'erlang':'>'/2)(_cor0, 1)
	   of _ker9
	     _ker9
	   catch 
	     'false'
	   end
	   ->
	     do
	       bif (remote 'erlang':'-'/2)(_cor0, 1) >> <Sm>
	     then
	     do
	       bif (remote 'erlang':'div'/2)(Sm, 2) >> <S2>
	     then
	     do
	       bif (remote 'erlang':'-'/2)(Sm, S2) >> <S1>
	     then
	     do
	       call (local 'balance_list_1'/2)(_cor1, S1) >> <_ker10>
	     then
	     match _ker10
	       alt
		 select _ker10
		   type k_tuple
		     {_ker13,_ker12} ->
		       select _ker12
			 type k_cons
			   [_ker15|_ker14] ->
			     select _ker15
			       type k_tuple
				 {_ker17,_ker16} ->
				   do
				     call (local 'balance_list_1'/2)(_ker14, S2) >> <_ker18>
				   then
				   match _ker18
				     alt
				       select _ker18
					 type k_tuple
					   {_ker21,_ker20} ->
					     do
					       {_ker17,_ker16,_ker13,_ker21} >> <T>
					     then
					     do
					       {T,_ker20} >> <_ker22>
					     then
					     <<_ker22>>
				       do
					 {'badmatch',_ker18} >> <_ker19>
				       then
				       enter (remote 'erlang':'error'/1)(_ker19)
				   end >> <>
		 do
		   {'badmatch',_ker10} >> <_ker11>
		 then
		 enter (remote 'erlang':'error'/1)(_ker11)
	     end >> <>
      alt
	select _cor1
	  type k_cons
	    [_ker5|_ker4] ->
	      select _ker5
		type k_tuple
		  {_ker7,_ker6} ->
		    select _cor0
		      type k_int
			1 ->
			  do
			    {_ker7,_ker6,'nil','nil'} >> <_ker8>
			  then
			  do
			    {_ker8,_ker4} >> <_ker23>
			  then
			  <<_ker23>>
	alt
	  select _cor0
	    type k_int
	      0 ->
		do
		  {'nil',_cor1} >> <_ker24>
		then
		<<_ker24>>
	  do
	    [_cor0] >> <_ker2>
	  then
	  do
	    [_cor1|_ker2] >> <_ker3>
	  then
	  enter (remote 'erlang':'error'/2)('function_clause', _ker3)
  end >> <>
fdef 'from_orddict'/1(_cor0) =
  do
    bif (remote 'erlang':'length'/1)(_cor0) >> <S>
  then
  do
    call (local 'balance_list'/2)(_cor0, S) >> <_cor2>
  then
  do
    {S,_cor2} >> <_ker0>
  then
  <<_ker0>>
fdef 'delete_any'/2(_cor1, _cor0) =
  do
    call (local 'is_defined'/2)(_cor1, _cor0) >> <_ker0>
  then
  match _ker0
    alt
      select _ker0
	type k_atom
	  'false' ->
	    <<_cor0>>
	  'true' ->
	    enter (local 'delete'/2)(_cor1, _cor0)
      do
	{'case_clause',_ker0} >> <_ker1>
      then
      enter (remote 'erlang':'error'/1)(_ker1)
  end >> <>
fdef 'delete'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker3,_ker2} ->
	    when 
		 try
		   do
		     bif (remote 'erlang':'is_integer'/1)(_ker3) >> <_cor2>
		   then
		   do
		     bif (remote 'erlang':'>='/2)(_ker3, 0) >> <_cor3>
		   then
		   do
		     bif (remote 'erlang':'and'/2)(_cor2, _cor3) >> <_ker5>
		   then
		   test (remote 'erlang':'=:='/2)(_ker5, 'true')
		 of _ker4
		   _ker4
		 catch 
		   'false'
		 end
		 ->
		   do
		     bif (remote 'erlang':'-'/2)(_ker3, 1) >> <_cor5>
		   then
		   do
		     call (local 'delete_1'/2)(_cor1, _ker2) >> <_cor4>
		   then
		   do
		     {_cor5,_cor4} >> <_ker6>
		   then
		   <<_ker6>>
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'delete_1'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker11,_ker10,_ker9,_ker8} ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'<'/2)(_cor1, _ker11)
		   of _ker12
		     _ker12
		   catch 
		     'false'
		   end
		   ->
		     do
		       call (local 'delete_1'/2)(_cor1, _ker9) >> <Smaller1>
		     then
		     do
		       {_ker11,_ker10,Smaller1,_ker8} >> <_ker15>
		     then
		     <<_ker15>>
		   try
		     test (remote 'erlang':'>'/2)(_cor1, _ker11)
		   of _ker13
		     _ker13
		   catch 
		     'false'
		   end
		   ->
		     do
		       call (local 'delete_1'/2)(_cor1, _ker8) >> <Bigger1>
		     then
		     do
		       {_ker11,_ker10,_ker9,Bigger1} >> <_ker14>
		     then
		     <<_ker14>>
	      enter (local 'merge'/2)(_ker9, _ker8)
      do
	[_cor0] >> <_ker6>
      then
      do
	[_cor1|_ker6] >> <_ker7>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker7)
  end >> <>
fdef 'merge'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_atom
	  'nil' ->
	    <<_cor1>>
      alt
	select _cor1
	  type k_atom
	    'nil' ->
	      <<_cor0>>
	do
	  call (local 'take_smallest1'/1)(_cor0) >> <_ker2>
	then
	match _ker2
	  alt
	    select _ker2
	      type k_tuple
		{_ker6,_ker5,_ker4} ->
		  do
		    {_ker6,_ker5,_cor1,_ker4} >> <_ker7>
		  then
		  <<_ker7>>
	    do
	      {'badmatch',_ker2} >> <_ker3>
	    then
	    enter (remote 'erlang':'error'/1)(_ker3)
	end >> <>
  end >> <>
fdef 'take_smallest'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    when 
		 try
		   do
		     bif (remote 'erlang':'is_integer'/1)(_ker2) >> <_cor1>
		   then
		   do
		     bif (remote 'erlang':'>='/2)(_ker2, 0) >> <_cor2>
		   then
		   do
		     bif (remote 'erlang':'and'/2)(_cor1, _cor2) >> <_ker4>
		   then
		   test (remote 'erlang':'=:='/2)(_ker4, 'true')
		 of _ker3
		   _ker3
		 catch 
		   'false'
		 end
		 ->
		   do
		     call (local 'take_smallest1'/1)(_ker1) >> <_ker5>
		   then
		   match _ker5
		     alt
		       select _ker5
			 type k_tuple
			   {_ker9,_ker8,_ker7} ->
			     do
			       bif (remote 'erlang':'-'/2)(_ker2, 1) >> <_cor4>
			     then
			     do
			       {_cor4,_ker7} >> <_ker10>
			     then
			     do
			       {_ker9,_ker8,_ker10} >> <_ker11>
			     then
			     <<_ker11>>
		       do
			 {'badmatch',_ker5} >> <_ker6>
		       then
		       enter (remote 'erlang':'error'/1)(_ker6)
		   end >> <>
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'take_smallest1'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker7,_ker6,_ker5,_ker4} ->
	    alt
	      select _ker5
		type k_atom
		  'nil' ->
		    do
		      {_ker7,_ker6,_ker4} >> <_ker14>
		    then
		    <<_ker14>>
	      do
		call (local 'take_smallest1'/1)(_ker5) >> <_ker8>
	      then
	      match _ker8
		alt
		  select _ker8
		    type k_tuple
		      {_ker12,_ker11,_ker10} ->
			do
			  {_ker7,_ker6,_ker10,_ker4} >> <_ker13>
			then
			do
			  {_ker12,_ker11,_ker13} >> <_ker15>
			then
			<<_ker15>>
		  do
		    {'badmatch',_ker8} >> <_ker9>
		  then
		  enter (remote 'erlang':'error'/1)(_ker9)
	      end >> <>
      do
	[_cor0] >> <_ker3>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker3)
  end >> <>
fdef 'smallest'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    enter (local 'smallest_1'/1)(_ker1)
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'smallest_1'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker5,_ker4,_ker3,_ker2} ->
	    alt
	      select _ker3
		type k_atom
		  'nil' ->
		    do
		      {_ker5,_ker4} >> <_ker6>
		    then
		    <<_ker6>>
	      enter (local 'smallest_1'/1)(_ker3)
      do
	[_cor0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'take_largest'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    when 
		 try
		   do
		     bif (remote 'erlang':'is_integer'/1)(_ker2) >> <_cor1>
		   then
		   do
		     bif (remote 'erlang':'>='/2)(_ker2, 0) >> <_cor2>
		   then
		   do
		     bif (remote 'erlang':'and'/2)(_cor1, _cor2) >> <_ker4>
		   then
		   test (remote 'erlang':'=:='/2)(_ker4, 'true')
		 of _ker3
		   _ker3
		 catch 
		   'false'
		 end
		 ->
		   do
		     call (local 'take_largest1'/1)(_ker1) >> <_ker5>
		   then
		   match _ker5
		     alt
		       select _ker5
			 type k_tuple
			   {_ker9,_ker8,_ker7} ->
			     do
			       bif (remote 'erlang':'-'/2)(_ker2, 1) >> <_cor4>
			     then
			     do
			       {_cor4,_ker7} >> <_ker10>
			     then
			     do
			       {_ker9,_ker8,_ker10} >> <_ker11>
			     then
			     <<_ker11>>
		       do
			 {'badmatch',_ker5} >> <_ker6>
		       then
		       enter (remote 'erlang':'error'/1)(_ker6)
		   end >> <>
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'take_largest1'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker7,_ker6,_ker5,_ker4} ->
	    alt
	      select _ker4
		type k_atom
		  'nil' ->
		    do
		      {_ker7,_ker6,_ker5} >> <_ker14>
		    then
		    <<_ker14>>
	      do
		call (local 'take_largest1'/1)(_ker4) >> <_ker8>
	      then
	      match _ker8
		alt
		  select _ker8
		    type k_tuple
		      {_ker12,_ker11,_ker10} ->
			do
			  {_ker7,_ker6,_ker5,_ker10} >> <_ker13>
			then
			do
			  {_ker12,_ker11,_ker13} >> <_ker15>
			then
			<<_ker15>>
		  do
		    {'badmatch',_ker8} >> <_ker9>
		  then
		  enter (remote 'erlang':'error'/1)(_ker9)
	      end >> <>
      do
	[_cor0] >> <_ker3>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker3)
  end >> <>
fdef 'largest'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    enter (local 'largest_1'/1)(_ker1)
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'largest_1'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker5,_ker4,_ker3,_ker2} ->
	    alt
	      select _ker2
		type k_atom
		  'nil' ->
		    do
		      {_ker5,_ker4} >> <_ker6>
		    then
		    <<_ker6>>
	      enter (local 'largest_1'/1)(_ker2)
      do
	[_cor0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'to_list'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    enter (local 'to_list'/2)(_ker1, [])
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'to_list_1'/1(_cor0) =
  enter (local 'to_list'/2)(_cor0, [])
fdef 'to_list'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor1
	type k_tuple
	  {_ker6,_ker5,_ker4,_ker3} ->
	    do
	      call (local 'to_list'/2)(_ker3, _cor0) >> <_cor2>
	    then
	    do
	      {_ker6,_ker5} >> <_ker7>
	    then
	    do
	      [_ker7|_cor2] >> <_ker8>
	    then
	    enter (local 'to_list'/2)(_ker4, _ker8)
	type k_atom
	  'nil' ->
	    <<_cor0>>
      do
	[_cor0] >> <_ker1>
      then
      do
	[_cor1|_ker1] >> <_ker2>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker2)
  end >> <>
fdef 'keys'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    enter (local 'keys'/2)(_ker1, [])
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'keys'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor1
	type k_tuple
	  {_ker6,_ker5,_ker4,_ker3} ->
	    do
	      call (local 'keys'/2)(_ker3, _cor0) >> <_cor2>
	    then
	    do
	      [_ker6|_cor2] >> <_ker7>
	    then
	    enter (local 'keys'/2)(_ker4, _ker7)
	type k_atom
	  'nil' ->
	    <<_cor0>>
      do
	[_cor0] >> <_ker1>
      then
      do
	[_cor1|_ker1] >> <_ker2>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker2)
  end >> <>
fdef 'values'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    enter (local 'values'/2)(_ker1, [])
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'values'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor1
	type k_tuple
	  {_ker6,_ker5,_ker4,_ker3} ->
	    do
	      call (local 'values'/2)(_ker3, _cor0) >> <_cor2>
	    then
	    do
	      [_ker5|_cor2] >> <_ker7>
	    then
	    enter (local 'values'/2)(_ker4, _ker7)
	type k_atom
	  'nil' ->
	    <<_cor0>>
      do
	[_cor0] >> <_ker1>
      then
      do
	[_cor1|_ker1] >> <_ker2>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker2)
  end >> <>
fdef 'iterator'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_tuple
	  {_ker2,_ker1} ->
	    enter (local 'iterator_1'/1)(_ker1)
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'iterator_1'/1(_cor0) =
  enter (local 'iterator'/2)(_cor0, [])
fdef 'iterator'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor1
	type k_tuple
	  {_ker8,_ker7,_ker6,_ker5} ->
	    alt
	      select _ker6
		type k_atom
		  'nil' ->
		    do
		      [_cor1|_cor0] >> <_ker10>
		    then
		    <<_ker10>>
	      do
		[_cor1|_cor0] >> <_ker9>
	      then
	      enter (local 'iterator'/2)(_ker6, _ker9)
	type k_atom
	  'nil' ->
	    <<_cor0>>
      do
	[_cor0] >> <_ker3>
      then
      do
	[_cor1|_ker3] >> <_ker4>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker4)
  end >> <>
fdef 'iterator_from'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker3,_ker2} ->
	    enter (local 'iterator_1_from'/2)(_cor1, _ker2)
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'iterator_1_from'/2(_cor1, _cor0) =
  enter (local 'iterator_from'/3)(_cor1, _cor0, [])
fdef 'iterator_from'/3(_cor2, _cor1, _cor0) =
  match _cor2,_cor1,_cor0
    alt
      select _cor1
	type k_tuple
	  {_ker12,_ker11,_ker10,_ker9} ->
	    alt
	      when 
		   try
		     test (remote 'erlang':'<'/2)(_ker12, _cor2)
		   of _ker14
		     _ker14
		   catch 
		     'false'
		   end
		   ->
		     enter (local 'iterator_from'/3)(_cor2, _ker9, _cor0)
	      alt
		select _ker10
		  type k_atom
		    'nil' ->
		      do
			[_cor1|_cor0] >> <_ker15>
		      then
		      <<_ker15>>
		do
		  [_cor1|_cor0] >> <_ker13>
		then
		enter (local 'iterator_from'/3)(_cor2, _ker10, _ker13)
	type k_atom
	  'nil' ->
	    <<_cor0>>
      do
	[_cor0] >> <_ker6>
      then
      do
	[_cor1|_ker6] >> <_ker7>
      then
      do
	[_cor2|_ker7] >> <_ker8>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker8)
  end >> <>
fdef 'next'/1(_cor0) =
  match _cor0
    alt
      select _cor0
	type k_cons
	  [_ker2|_ker1] ->
	    select _ker2
	      type k_tuple
		{_ker6,_ker5,_ker4,_ker3} ->
		  do
		    call (local 'iterator'/2)(_ker3, _ker1) >> <_cor1>
		  then
		  do
		    {_ker6,_ker5,_cor1} >> <_ker7>
		  then
		  <<_ker7>>
	type k_nil
	  [] ->
	    <<'none'>>
      do
	[_cor0] >> <_ker0>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker0)
  end >> <>
fdef 'map'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker3,_ker2} ->
	    when 
		 try
		   test (remote 'erlang':'is_function'/2)(_cor1, 2)
		 of _ker4
		   _ker4
		 catch 
		   'false'
		 end
		 ->
		   do
		     call (local 'map_1'/2)(_cor1, _ker2) >> <_cor2>
		   then
		   do
		     {_ker3,_cor2} >> <_ker5>
		   then
		   <<_ker5>>
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'map_1'/2(_cor1, _cor0) =
  match _cor1,_cor0
    alt
      select _cor0
	type k_tuple
	  {_ker5,_ker4,_ker3,_ker2} ->
	    do
	      call (_cor1)(_ker5, _ker4) >> <_cor4>
	    then
	    do
	      call (local 'map_1'/2)(_cor1, _ker3) >> <_cor3>
	    then
	    do
	      call (local 'map_1'/2)(_cor1, _ker2) >> <_cor2>
	    then
	    do
	      {_ker5,_cor4,_cor3,_cor2} >> <_ker6>
	    then
	    <<_ker6>>
	type k_atom
	  'nil' ->
	    <<'nil'>>
      do
	[_cor0] >> <_ker0>
      then
      do
	[_cor1|_ker0] >> <_ker1>
      then
      enter (remote 'erlang':'error'/2)('function_clause', _ker1)
  end >> <>
fdef 'module_info'/0() =
  enter (remote 'erlang':'get_module_info'/1)('gb_trees')
fdef 'module_info'/1(_cor0) =
  enter (remote 'erlang':'get_module_info'/2)('gb_trees', _cor0)
end